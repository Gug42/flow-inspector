#!/usr/bin/env python 

"""
This script performs the live checks on the host list that has been
generated by add_devices_to_monitoring. It employs the fping tool and
requires that the user running this script has the rights to run fping.
fping also must be in the default path of the user.
"""

import sys
import os.path

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'config'))
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'lib'))
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'vendor'))

import common
import common_functions
import subprocess
import backend
import time

def perform_live_check(ip_list):
	"""
	Retrieves a list of IP addresses that should be checked. All IPs 
	are checked with fping and a list of unreachable IPs is returend to the caller.
	"""
	fping_pipe = subprocess.Popen(['fping', '-u', '-i', '10', '-p', '20', '-t', '50'], stdout=subprocess.PIPE,stdin=subprocess.PIPE)
	#fping_pipe = subprocess.Popen(['fping', '-u', '-i', '10', '-p', '20', '-r', '19', '-t', '50'], stdout=subprocess.PIPE,stdin=subprocess.PIPE)

	input_for_fping = ""
	for ip in monitoring_ips:
		input_for_fping += ip + "\n"

	print "Starting fping ..."
	output = fping_pipe.communicate(input=input_for_fping)[0].split('\n')
	print "fping finsihed ..."
	
	
	unreachable_ips = []
	for line in output:
		line = line.rstrip('\n')
		# skip empty lines
		if len(line) == 0:
			continue
		unreachable_ips.append(line)
	return unreachable_ips



if __name__ == "__main__":
	parser = common.get_default_argument_parser("Tool for performing live checks on the devices that require the monitoring")

	args = parser.parse_args()

	dst_db = backend.databackend.getBackendObject(
		args.backend, args.dst_host, args.dst_port,
		args.dst_user, args.dst_password, args.dst_database)

	measurement_map_filename =  os.path.join(os.path.dirname(__file__), "..", "config",  "monitoring_devices.csv")
	for name, fields in common_functions.read_field_dict_from_csv(args.backend, measurement_map_filename).items():
		dst_db.prepareCollection(name, fields)


	device_table = dst_db.getCollection("device_table")
	live_check_table = dst_db.getCollection("live_check_table")

		
	# get the ips that should be monitored
	resultSet = device_table.find({'do_live_check': 1}, {'_id': 1, 'ip': 1})
	monitoring_ips = dict()
	for result in resultSet:
		monitoring_ips[result['ip']] = result

	timestamp = time.time()
	unreachable_list = perform_live_check(monitoring_ips)

	# get the result set from the last run
	resultSet = live_check_table.find({})
	previous_results = dict()
	for result in resultSet:
		previous_results[result['device_id']] = result

	# first: check if we need an update on the devices that we 
	# now found unreachble
	for ip in unreachable_list:
		device_id = monitoring_ips[ip]['_id']
		table_entry = {}
		if not device_id in previous_results:
			# no entries for this IP. So this is the first fail. 
			# create a new entry for the IP
			table_entry = {}
			table_entry['last_checked'] = timestamp
			table_entry['first_fail'] = timestamp
			table_entry['last_fail'] = timestamp
			table_entry['status'] = 0
		else:
			# device has previously failed 
			table_entry = previous_results[device_id]
			table_entry['last_checked'] = timestamp
			table_entry['last_fail'] = timestamp
			if table_entry['status'] == 1:
				# device was available in the mean time but is gone again
				# update status and first_fail timestamp to current
				# time stamp
				table_entry['status'] = 0
				table_entry['first_fail'] = 0
			# remove this ip from the list (we need to update the others later on 
			del previous_results[device_id]
				

		doc = {}
		doc["$set"] = table_entry
		live_check_table.update({"device_id": device_id}, doc)
		
	# the remaining ips in the monitoring list are online. update their last_check status
	for device_id in previous_results:
		table_entry = previous_results[device_id]
		table_entry["status"] = 1
		table_entry["last_checked"] = timestamp
		doc = {}
		doc["$set"] = table_entry
		live_check_table.update({"device_id": device_id}, doc)
	live_check_table.flushCache()
		

